#基础算法

##sort排序

###快排quick_sort

 ==注意x这种轴心的取值，不要取q[l],注意i=l-1，j=r+1==

```c++
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int i = l - 1, j = r + 1, x = q[l + r >> 1];	
    //注意x这种轴心的取值，不要取q[l],注意i=l-1，j=r+1
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```

​           



###归并排序

==注意此处的q[i]<=q[j],保证了稳定==

==最后要继续填充==

```c++
while (i <= mid) tmp[k ++ ] = q[i ++ ];			
while (j <= r) tmp[k ++ ] = q[j ++ ];
```

==记得i从l开始到r，要实现将temp复制到q[i]==

~~~c++
   for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];		
~~~

```c++
void merge_sort(int q[], int l, int r)
{
    if (l >= r) return;			

    int mid = l + r >> 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);

    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
        if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];		//注意此处的q[i]<=q[j],保证了稳定
        else tmp[k ++ ] = q[j ++ ];

    while (i <= mid) tmp[k ++ ] = q[i ++ ];				//最后要继续填充
    while (j <= r) tmp[k ++ ] = q[j ++ ];

    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];		
    //记得i从l开始到r，要实现将temp复制到q[i]
}
```

### 二分排序

典型二分法则

==重要代码部分==

```c++
bool check(int x) {/* ... */} // 检查x是否满足某种性质
```

r=mid,mid=r+l>>1;

l=mid,mid=r+l+1>>1;



数的范围

```c++
bool check(int x) {/* ... */} // 检查x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
    return l;
}
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```





##高精度算法

###高精度加法

==最后需要判断最后一位是否进位==

```c++
#include<iostream>
using namespace std;
#include<string>
#include<vector>

int const N=1e6+10;

vector<int> add(vector<int> &A,vector<int> &B){
    vector<int>  C;
    int c=0,i=0;		//进位
    while(i<A.size() || i<B.size()){
        if(i<A.size())  c+=A[i];
        if(i<B.size())  c+=B[i];
        i++;
        C.push_back(c%10);
        c/=10;	
    }
    if(c)   C.push_back(c);			//最后需要判断最后一位是否进位
    return C;
}}

int main(){

   string a,b;
   cin>>a>>b;		//将数字转化为字符串

    vector<int> A,B;
    for(int i=a.size()-1;i>=0;i--)  A.push_back(a[i]-'0');		
    //a[i]-'0'，且逆向输入vector
    for(int i=b.size()-1;i>=0;i--)  B.push_back(b[i]-'0');
    
    vector<int> C=add(A,B);				
    
    for(int i=C.size()-1;i>=0;i--)  printf("%d",C[i]);			//逆向输出C
    return 0;
}

```





### 高精度减法

==需要注意的三处代码==

~~~c++
if(i<B.size())   t-=B[i];		//注意此处B位数的判断
C.push_back((t+10)%10);			//注意此处的操作
if(t<0)  t=1;					//注意此处t的判断赋值

while(C.size()>1 && C.back()==0)    C.pop_back();	
    //注意此处的去除前导0但不去除第一个0

  if(!compare(a,b))   printf("-");		//负数则输出'-'
~~~

**完整代码**

~~~c++
#include<iostream>
using namespace std;
#include<string>
#include<vector>

int const N=1e6+10;

//当a>=b,返回1；
bool compare(string &a,string &b){
    if(a.size()!=b.size()) return a.size()>b.size();
    for(int i=0;i<a.size();i++) {
    if(a[i]!=b[i])   return a[i]>b[i];
    }
    return true;
    
}

vector<int> sub(vector<int> &A,vector<int> &B){
   vector<int> C;
   int t=0;   //进位
   for(int i=0;i<A.size();i++){
       t=A[i]-t;
       if(i<B.size())   t-=B[i];		//注意此处B位数的判断
       C.push_back((t+10)%10);			//注意此处的操作
       if(t<0)  t=1;					//注意此处t的判断赋值
       else t=0;
   }
   while(C.size()>1 && C.back()==0)    C.pop_back();	
    //注意此处的去除前导0但不去除第一个0
   return C;
}



int main(){
   
   string a,b;
   cin>>a>>b;
   
    vector<int> A,B,C;
    for(int i=a.size()-1;i>=0;i--)  A.push_back(a[i]-'0');	
    for(int i=b.size()-1;i>=0;i--)  B.push_back(b[i]-'0');
    
    if(compare(a,b))    C=sub(A,B);
    else    C=sub(B,A);
    if(!compare(a,b))   printf("-");		//负数则输出'-'
    for(int i=C.size()-1;i>=0;i--)  printf("%d",C[i]);
    return 0;
}
    

~~~







### 高精度乘法



**完整代码**

~~~c++
#include<iostream>
using namespace std;
#include<string>
#include<vector>

vector<int> mul(vector<int> &A,int b){
    vector<int>  C;
    int t=0;      
    for(int i=0;i<A.size() || t;i++){
        if(i<A.size())  t+=A[i]*b;
        C.push_back(t%10);
        t/=10;
    }
    //去除前导0；
    while(C.size()>1&&C.back()==0)  C.pop_back();
    return C;
}

int main(){
    string a;//a是位数大数，b是位数小数
    int b;
    cin>>a>>b;
    //倒序输入A，B
    vector<int> A;
    for(int i=a.size()-1;i>=0;i--)   A.push_back(a[i]-'0');
       
    
    auto C=mul(A,b);		
    
    for(int i=C.size()-1;i>=0;i--)  printf("%d",C[i]);
}
~~~









### 高精度除法

==重点代码==

==特别除以b==

~~~c++
for(int i=A.size()-1;i>=0;i--){     //注意此时A是逆向储存的，除法是正向的，所以从i=A.size()-1开始
        r=r*10+A[i];
        C.push_back(r/b);               //此处除以的是b！！！！！！！！
        r%=b;                           //此处模的是b!!!!!!!!!!!!!!!!!
    }
    reverse(C.begin(),C.end());         //C是正向的，为保证加减乘除的统一输出，此时将C逆向
    while(C.size()>1 && C.back()==0)    C.pop_back();       //除去前导0；
~~~

**完整代码**

~~~c++
#include<iostream>
using namespace std;
#include<string>
#include<algorithm>

vector<int> div(vector<int> &A,int b,int &r){       //此时r作为引用传入，作为余数
    vector<int> C;
    
    r=0;
    for(int i=A.size()-1;i>=0;i--){     //注意此时A是逆向储存的，除法是正向的，所以从i=A.size()-1开始
        r=r*10+A[i];
        C.push_back(r/b);               //此处除以的是b！！！！！！！！
        r%=b;                           //此处模的是b!!!!!!!!!!!!!!!!!
    }
    reverse(C.begin(),C.end());         //C是正向的，为保证加减乘除的统一输出，此时将C逆向
    while(C.size()>1 && C.back()==0)    C.pop_back();       //除去前导0；
    return C;
}

int main(){
    string a;
    int b,r;
    cin>>a>>b;
    vector<int> A;
    for(int i=a.size()-1;i>=0;i--)     A.push_back(a[i]-'0');
    
    auto C=div(A,b,r);
    
    for(int i=C.size()-1;i>=0;i--)  printf("%d",C[i]);
    printf("\n%d",r);
    return 0;
    
}
~~~



## 前缀和与差分



###一维前缀和

即**s[i]=a0+a1+........ai**;

则求**al+.......+ar**的和为**s[r]-s[l-1]**;

~~~c++
#include<iostream>
using namespace std;

int const N=1e5+10;
int s[N],a[N];
int n,m;

int main(){
    scanf("%d%d",&n,&m);
    
    for(int i=1;i<=n;i++)   scanf("%d",&a[i]);
    
    for(int i=0;i<=n;i++)   s[i]=s[i-1]+a[i];
    int l,r;
    while(m--){
        scanf("%d%d",&l,&r);
        printf("%d\n",s[r]-s[l-1]);
    }
    return 0;
    
}
~~~



### 二维前缀和

易得出

*前缀和*					==**s\[x] [y] = s\[x-1] [y] + s\[x] [y-1] - s\[x-1] [y-1] + a\[x] [y]**==	

*部分和*					==**s = s[x2] [y2] - s[x1-1] [y2] - s[x2] [y1-1] + s[x1-1] [y1-1]**==

~~~c++
#include<iostream>
using namespace std;

int const N = 1010;
int n,m,q;
int a[N][N],s[N][N];


int main(){
    
    cin>>n>>m>>q;
    for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
    scanf("%d",&a[i][j]);
    
    for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
    s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];	//前缀和
    
    int x1,y1,x2,y2;
    while(q--){
        scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
        printf("%d\n",s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1]);	//部分和
    }
    return 0;
}

~~~



### 一维差分

要在已知的的数组a[]的l到r位置上加上c，操作极多次数，则将a看成b的前缀和，b称为a的为差分

**公式**==a[n]=b[1]+b[2]+b[3]..........+b[n]==

**重要code**

~~~c++
 for(int i=0;i<=n;i++)   b[i]=a[i]-a[i-1];           //构建差分数组

while(m--){											//对b[l]进行加c，对b[r+1]减c
        int l,r,c;
        scanf("%d%d%d",&l,&r,&c);
        b[l]+=c;
        b[r+1]-=c;
    }    
~~~



**完整code**

~~~c++
#include<iostream>
using namespace std;

int const N = 100010;
int a[N],b[N];
int n,m;

int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)   scanf("%d",&a[i]);
    for(int i=0;i<=n;i++)   b[i]=a[i]-a[i-1];           //构建差分数组
    
    while(m--){
        int l,r,c;
        scanf("%d%d%d",&l,&r,&c);
        b[l]+=c;
        b[r+1]-=c;
    }    
    for(int i=1;i<=n;i++){
        a[i]=b[i]+a[i-1];
        printf("%d ",a[i]);
    }
    return 0;
}
~~~



### 差分矩阵

==key code==

```c++
void insert(int x1,int y1,int x2,int y2,int c){			//心中画好图，自然记得住
    b[x1][y1]+=c;
    b[x2+1][y1]-=c;
    b[x1][y2+1]-=c;
    b[x2+1][y2+1]+=c;
}


 for(int i=1;i<=n;i++){									//记录a[i]时同时记录b[i]
        for(int j=1;j<=m;j++){
            scanf("%d",&a[i][j]);
            insert(i,j,i,j,a[i][j]);					//给b赋初值
        }
    }
```





==source code==

```c++
 #include<iostream>
using namespace std;

int const N =1010;
int m,n,q;
int a[N][N],b[N][N];

void insert(int x1,int y1,int x2,int y2,int c){
    b[x1][y1]+=c;
    b[x2+1][y1]-=c;
    b[x1][y2+1]-=c;
    b[x2+1][y2+1]+=c;
}


int main(){
    cin>>n>>m>>q;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            scanf("%d",&a[i][j]);
            insert(i,j,i,j,a[i][j]);
        }
    }

    
    int x1,x2,y1,y2,c;
    while(q--){
        scanf("%d%d%d%d%d",&x1,&y1,&x2,&y2,&c);
        insert(x1,y1,x2,y2,c);
    }
    
     for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            a[i][j]=a[i-1][j]+a[i][j-1]-a[i-1][j-1]+b[i][j];
            printf("%d ",a[i][j]);
        }
        printf("\n");
    }
}
```


##离散化 
###区间和

将大范围映射成小范围

~~~c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

typedef pair<int, int> PII;
const int N = 300010;
int a[N], s[N];
int n, m;

vector<int> alls;
vector<PII> add, query;

int find(int x)
{
    int l = 0, r = alls.size() - 1;
    while(l < r)
    {
        int mid = l + r >> 1;
        if(alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1;
}
vector<int>:: iterator unique(vector<int> &a)
{
    int j = 0;
    for(int i = 0; i < a.size(); i ++)
        if(!i || a[i] != a[i - 1])
            a[j ++ ] = a[i];
    return a.begin() + j;
}

int main()
{

    cin >> n >> m;

    for(int i = 0; i < n; i ++ )
    {
        int x, c;
        cin >> x >> c;
        add.push_back({x, c});

        alls.push_back(x);
    }

    for(int i = 0; i < m; i ++ )
    {
        int l, r;
        cin >> l >> r;
        query.push_back({l, r});

        alls.push_back(l);
        alls.push_back(r);
    }

    sort(alls.begin(), alls.end());
    alls.erase(unique(alls), alls.end());

    for(auto item : add)
    {
        int x = find(item.first);
        a[x] += item.second;
    }

    for(int i = 1; i <= alls.size(); i ++ ) s[i] = s[i - 1] + a[i];

    for(auto item : query)
    {
        int l = find(item.first), r = find(item.second);
        cout << s[r] - s[l - 1] << endl;
    }

    return 0;
}
~~~
###区间合并

**注意sort()对vector<int,int>的排序规则**

**注意在将seg加入res时，判断是否st=-2e9,即是否为空**

~~~c++
#include<iostream>
#include<vector>
using namespace std;
#include<algorithm>

typedef pair<int,int> PII;
vector<PII> segs;
int n;

void merge(vector<PII> &segs)
{
    vector<PII> res;
    int st=-2e9,ed=-2e9;
    for(auto seg:segs)
    {
        if(ed<seg.first)
        {
            if(st!=-2e9)    res.push_back({st,ed});			//注意此处的判断	
            st=seg.first;
            ed=seg.second;
        }
        else    ed=max(ed,seg.second);
    }
    if(st!=-2e9)    res.push_back({st,ed});					//注意此处的判断
    segs=res;
}
    
int main(){
    cin>>n;
    while(n--){
        int l,r;
        cin>>l>>r;
        segs.push_back({l,r});
    }
    sort(segs.begin(),segs.end());						
    //先将seg.first排序，再排seg.second
    merge(segs);
    cout<<segs.size();
    return 0;
}
~~~



#数据结构

###单链表

**理解记住喽，静态链表**

~~~C++
#include <iostream>
using namespace std;
const int N = 100010;

int head, e[N], ne[N], idx;

void init()
{
    head = -1;
    idx = 0;
}

void add_to_head(int x)
{
    e[idx] = x, ne[idx] = head, head = idx++;
}

void add(int k, int x)
{
    e[idx] = x, ne[idx] = ne[k], ne[k] = idx++;
}

void remove(int k)
{
    ne[k] = ne[ne[k]];
}

int main()
{
    int m;
    cin >> m;

    init();

    while(m--)
    {
        char op;
        int k, x;
        cin >> op;
        if(op == 'H')
        {
            cin >> x;
            add_to_head(x);
        }
        else if(op == 'D')
        {
            cin >> k;
            if(!k) head = ne[head];
            else remove(k - 1);//第k个元素对应的索引为k - 1
        }
        else 
        {
            cin >> k >> x;
            add(k - 1, x);//第k个元素对应的索引为k - 1
        }
    }
    for(int i = head; i != -1; i = ne[i]) cout << e[i] << " ";

    cout<< endl;
}
~~~



### 双链表

****

**==重点==**			***对应的索引：左端点是0，右端点是1，初始化的时候r[0]=1,l[1]=0,idx=2***

~~~C++
#include<iostream>

using namespace std;

const int N = 1e5 + 10;

int m;
int e[N], l[N], r[N];
int idx;


//! 初始化
void init()
{
    l[1] = 0, r[0] = 1;//* 初始化 第一个点的右边是 1   第二个点的左边是 0
    idx = 2;//! idx 此时已经用掉两个点了
}

//* 在第 K 个点右边插入一个 X 
void add(int k, int x)
{
    e[idx] = x;
    l[idx] = k;
    r[idx] = r[k]; //todo 这边的 k 不加 1 ， 输入的时候 k+1 就好
    l[r[k]] = idx;
    r[k] = idx;
    idx++;
}//! 当然在 K 的左边插入一个数 可以再写一个 ， 也可以直接调用我们这个函数，在 k 的左边插入一个 数 等价于在 l[k] 的右边插入一个数 add(l[k],x)

//*删除第 k个 点
void remove(int k)
{
    r[l[k]] = r[k];
    l[r[k]] = l[k];
}

int main(void)
{
    ios::sync_with_stdio(false);
    cin >> m;

    init();

    while(m--)
    {
        string op;
        cin >> op;
        int k, x;
        if(op=="R")
        {
            cin >> x;
            add(l[1], x); //!   0和 1 只是代表 头和尾  所以   最右边插入 只要在  指向 1的 那个点的右边插入就可以了
        }
        else if(op=="L")//! 同理  最左边插入就是 在指向 0的数的左边插入就可以了   也就是可以直接在 0的 有右边插入
        {
            cin >> x;
            add(0, x);
        }
        else if(op=="D")
        {
            cin >> k;
            remove(k + 1);
        }
        else if(op=="IL")
        {
            cin >> k >> x;
            add(l[k + 1], x);
        }
        else
        {
            cin >> k >> x;
            add(k + 1, x);
        }    
    }
    for(int i = r[0]; i != 1; i = r[i]) cout << e[i] << ' ';		//注意是从r[0]开始

    return 0;
}
~~~





## 模拟栈和队列



~~~C++
#include<iostream>
using namespace std;

int const N=100010;
int stk[N],tt=0;

void push(int x)		//压栈
{
	stk[++tt]=x;
}

void pop()				//弹栈
{
	tt--;
}

bool emyty()			//判空
{
	return !tt;
}

int querry()			//查询栈顶元素
{
	return stk[tt];
}



~~~



### 单调栈

~~~C++
#include <iostream>
using namespace std;
const int N = 100010;
int stk[N], tt;

int main()
{
    int n;
    cin >> n;
    while (n -- )
    {
        int x;
        scanf("%d", &x);
        while (tt && stk[tt] >= x) tt -- ;//如果栈顶元素大于当前待入栈元素，则出栈
        if (!tt) printf("-1 ");//如果栈空，则没有比该元素小的值。
        else printf("%d ", stk[tt]);//栈顶元素就是左侧第一个比它小的元素。
        stk[ ++ tt] = x;
    }
    return 0;
}
~~~



###单调队列

~~~C++
# include <iostream>
using namespace std;
const int N = 1000010;
int a[N], q[N], hh, tt = -1;

int main()
{
    int n, k;
    cin >> n >> k;
    
    
    cout << endl;
    hh = 0; tt = -1;                                   
    // 重置！
    for (int i = 0; i < n; ++ i)
    {
        if (i - k + 1 > q[hh]) ++ hh;	//注意此处的是无等号，因为i是现在的i，i-k+1算出的现在的长度
        while (hh <= tt && a[i] >= a[q[tt]]) -- tt;
        q[++ tt] = i;
        if (i + 1 >= k) printf("%d ", a[q[hh]]);
    }
    return 0;
}
~~~



### kmp算法

**==重点==**

*next数组和匹配的code*

**s[m],p[n],ne[n]都是从下标1开始计数的**

~~~C++
char p[N];
int ne[N];

for(int i=2,j=0;i<=n;i++)			//注意next的i是从2开始的
{
	while(j && p[j+1]!=p[i])	j=ne[j];
	if(p[i]==p[j+1])	j++;    
    ne[i]=j;
}


//匹配
for(int i=1,j=0;i<=m;i++)			//注意匹配的时候i是从1开始的
{
	while(j && p[j+1]!=s[i])	j=ne[j];
    if(p[j+1]==s[i])	j++;
    if(j==n)
    {
        //匹配的结果
       	j=ne[j];
    }
}
return 0;
~~~









~~~C++
#include<iostream>
using namespace std;

int const N = 1e5,M=1e6;
char s[M],p[N];
int m,n,ne[N];

int main()
{
    cin>>n>>p+1>>m>>s+1;
    
    //next数组
    for(int i=2,j=0;i<=n;i++)
    {
        while(j && p[i]!=p[j+1])    j=ne[j];
        if(p[i] == p[j+1])  j++;
        ne[i]=j;
    }
    
    //
    for(int i=1,j=0;i<=m;i++)
    {
        while(j && s[i]!=p[j+1])    j=ne[j];
        if(s[i] == p[j+1])  j++;
        if(j == n)
        {
            j=ne[j];
            printf("%d ",i-n);
        }
    }
    
    return 0;
}
~~~



### Trie字符串统计

~~~~C++
int const N =1e9, n=100;		//N表示字符串的字母的总字数，n表示每串字符的最大长度

char s[n];
int son[N][26];

void insert(s[n])			//trie树的插入
{
    int p=0
	for(int i=0;s[i];i++ )
    {
        int u=s[i]-'a';
        if(!son[p][u])	son[p][u]=++idx;	//注意判空操作。注意idx++操纵
        p=son[p][u];
    }
    cnt[p]++;
}

int query(s[n])
{
	int p=0;
    for(int i=0;s[i];i++)
    {
        int u=s[i]-'a';
        if(!son[p][u])	return 0;			//注意判空操作
        p=son[p][u];
    }
    return cnt[p];


}


int main()
{
	int m;
    cin>>m;
    while(m--)
    {
        
    }
}

~~~~



### 合并查找

~~~C++
#include<iostream>
using namespace std;

int const N = 100010;
int p[N];

int find(int a)
{
    if(p[a]!=a) p[a]=find(p[a]);			//注意pa[a]=find[p[a]];
    return p[a];
}

int main()
{
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++)   p[i]=i;
    while(m--)
    {
        char op[2];
        int a,b;
        scanf("%s%d%d",op,&a,&b);
        if(op[0]=='M')  p[find(a)]=find(b);
        else
        {
            if(find(a)==find(b))    printf("Yes\n");
            else    printf("No\n");
        }
    }
    return 0;
}


~~~



### 连通块中的数量

~~~C++
#include<iostream>
using namespace std;

int const N = 100010;
int p[N],cnt[N];

int find(int x)
{
    if(x!=p[x]) p[x]=find(p[x]);
    return p[x];
}

int main()
{
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++)   p[i]=i,cnt[i]++;
    while(m--)
    {
        char op[2];
        int a,b;
        scanf("%s",op);
        if(op[0]=='C')  
        {
            int a,b;
            scanf("%d%d",&a,&b);
            if(find(a)==find(b))    continue;
            else
            {
                p[find(a)]=find(b);
                cnt[find(b)]+=cnt[find(a)];
            }
        }
        else if(op[1]=='1')
        {
            int a,b;
            scanf("%d%d",&a,&b);
            if(find(a)==find(b))    printf("Yes\n");
            else    printf("No\n");
        }
        else
        {
            int a;
            scanf("%d",&a);
            printf("%d\n",cnt[find(a)]);
        }
    }
    return 0;
}
~~~



## 模拟堆

int h[N];  //堆

int ph[N];  //存放第k个插入点的下标

int hp[N];  //存放堆中点的插入次序

int cur_size;  //size 记录的是堆当前的数据多少

~~~C++
#include<iostream>
#include<algorithm>
using namespace std;

int const N =100010;

int heap[N],ph[N],hp[N];
int heap_size=0,idx=0;

void heap_swap(int u,int v)
{
    swap(heap[u],heap[v]);
    swap(hp[u],hp[v]);					。//注意记忆此处
    swap(ph[hp[u]],ph[hp[v]]);
}

void down(int u)
{
    int t=u;
    if(2*u<=heap_size && heap[t]>heap[2*u]) t=2*u;
    if(2*u+1<=heap_size && heap[t]>heap[2*u+1]) t=2*u+1;
    if(u!=t)
    {
        heap_swap(t,u);
        down(t);
    }
}

void up(int u)
{
    int t=u;
    if(u/2 && heap[t]<heap[u/2])    t=u/2;
    if(u != t)
    {
        heap_swap(t,u);
        up(t);
    }    
}

int main()
{
    int m;
    cin>>m;
    while(m--)
    {
        string op;
        int k,x;
        cin>>op;
        if(op=="I")
        {
            cin>>x;
            heap[++heap_size]=x;	//注意++heap；
            ph[++idx]=heap_size;	//注意++
            hp[heap_size]=idx;	
            up(heap_size);
        }
        else if(op=="PM")    cout<<heap[1]<<endl;
        else if(op=="DM")
        {
            heap_swap(heap_size,1);
            heap_size--;
            down(1);		//注意down（1）
        }
        else if(op=="D")
        {
            cin>>k;
            int t=ph[k];		//注意记录此时的ph[k];
            heap_swap(ph[k],heap_size);
            heap_size--;
            down(t);
            up(t);
        }
        else if(op=="C")
        {
            cin>>k>>x;
            heap[ph[k]]=x;
            down(ph[k]);
            up(ph[k]);
        }
    }
        return 0;
}
~~~

##模拟散列表

####拉链法

**注意拉链法的h[k]的值是头节点对应的下标**

~~~C++
#include<iostream>
#include<cstring>

using namespace std;
int const N = 100003;

int h[N],e[N],ne[N],idx;
void insert(int x)
{
    int k=(x%N+N)%N;
    e[idx]=x;
    ne[idx]=h[k];
    h[k]=idx++;
}

bool find(int x)
{
    int k=(x%N+N)%N;
    for(int i=h[k];i!=-1;i=ne[i])
    {
        if(e[i]==x) return true;
    }
    return false;
}

int main()
{
    int m;
    cin>>m;
    memset(h,-1,sizeof(h));
    
    while(m--)
    {
        char op[2];
        int x;
        scanf("%s%d",op,&x);
        if(op[0]=='I')
        {
            insert(x);
        }
        else
        {
            if(find(x)) printf("Yes\n");
            else printf("No\n");
        }
    }
    return 0;
}
~~~

### 开放寻址法

**易错点**

~~~C++
memset(h,0x3f,sizeof(h));		//注意memset()的用法是0x3f；

if(h[find(x)]!=null) printf("Yes\n");			
            //注意此处的判断是对h[find[x]]是否等于null进行判断
            else printf("No\n");
~~~



~~~C++
#include<iostream>
#include<cstring>

using namespace std;
int const N = 200003;
int h[N];
int null=0x3f3f3f3f;

int find(int x)
{
    int k=(x%N+N)%N;
    while(h[k] !=null && h[k]!=x)   k=(k+1)%N;
    return k;
}

int main()
{
    int m;
    cin>>m;
    memset(h,0x3f,sizeof(h));		//注意memset()的用法是0x3f；
    
    while(m--)
    {
        char op[2];
        int x;
        scanf("%s%d",op,&x);
        if(op[0]=='I')
        {
            int k=find(x);
            h[k]=x;
        }
        else
        {
            if(h[find(x)]!=null) printf("Yes\n");			
            //注意此处的判断是对h[find[x]]是否等于null进行判断
            else printf("No\n");
        }
    }
    return 0;
}

~~~



##字符串哈希

**重要code**

~~~C++
int h[N],p[N];              
//注意h[0]=0,h有效是从1开始的，即"abcd"中"a""的哈希值是h[1];
//p[0]=1,p[n]即p^n
int const P=131;            //p可取131或者13331



 for(int i=0;i<n;i++)        //记住要让h[n]和p[n]取到值
    {
        p[i+1]=p[i]*P;
        h[i+1]=h[i]*P+s[i];
    }



if((h[r1]-h[l1-1]*p[r1-l1+1]) == h[r2]-h[l2-1]*p[r2-l2+1])  
        //p[x]中的x的值等于h[a]和h[b]的差值a-b；
~~~



~~~C++
#include<iostream>
using namespace std;

int const N = 100010;
int h[N],p[N];              
//注意h[0]=0,h有效是从1开始的，即"abcd"中"a""的哈希值是h[1];
//p[0]=1,p[n]即p^n
int const P=131;            //p可取131或者13331

int main()
{
    int m,n;
    cin>>n>>m;
    p[0]=1;
    h[0]=0;
    string s;
    cin>>s;
    
    for(int i=0;i<n;i++)        //记住要让h[n]和p[n]取到值
    {
        p[i+1]=p[i]*P;
        h[i+1]=h[i]*P+s[i];
    }
    
    while(m--)
    {
        int l1,r1,l2,r2;
        cin>>l1>>r1>>l2>>r2;
        if((h[r1]-h[l1-1]*p[r1-l1+1]) == h[r2]-h[l2-1]*p[r2-l2+1])  
        //p[x]中的x的值等于h[a]和h[b]的差值a-b；
        printf("Yes\n");
        else    printf("No\n");
    }
    
}

~~~

##STL

~~~C++
vector, 变长数组，倍增的思想
    size()  返回元素个数
    empty()  返回是否为空
    clear()  清空
    front()/back()
    push_back()/pop_back()
    begin()/end()
    []
    支持比较运算，按字典序
~~~
###pair<int, int>
~~~C++
pair<int, int>
    first, 第一个元素
    second, 第二个元素
    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）
~~~
###string，字符串
~~~C++
string，字符串
    size()/length()  返回字符串长度
    empty()
    clear()
    substr(起始下标，(子串长度))  返回子串
    c_str()  返回字符串所在字符数组的起始地址
~~~
###queue, 队列
~~~C++
queue, 队列
    size()
    empty()
    push()  向队尾插入一个元素
    front()  返回队头元素
    back()  返回队尾元素
    pop()  弹出队头元素,返回值为void
~~~
###priority_queue, 优先队列，默认是大根堆
~~~C++
priority_queue, 优先队列，默认是大根堆
    size()
    empty()
    push()  插入一个元素
    top()  返回堆顶元素
    pop()  弹出堆顶元素,
    定义成小根堆的方式：priority_queue<int, vector<int>, greater<int>> q;
~~~
###stack, 栈
~~~C++
stack, 栈
    size()
    empty()
    push()  向栈顶插入一个元素
    top()  返回栈顶元素
    pop()  弹出栈顶元素
~~~
###deque, 双端队列
~~~C++
deque, 双端队列
    size()
    empty()
    clear()
    front()/back()
    push_back()/pop_back()
    push_front()/pop_front()
    begin()/end()
    []
~~~
###set, map, multiset, multimap
~~~C++
set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列
    size()
    empty()
    clear()
    begin()/end()
    ++, -- 返回前驱和后继，时间复杂度 O(logn)
~~~
###set/multiset
~~~C++
    set/multiset
        insert()  插入一个数
        find()  查找一个数
        count()  返回某一个数的个数
        erase()
            (1) 输入是一个数x，删除所有x   O(k + logn)
            (2) 输入一个迭代器，删除这个迭代器
        lower_bound()/upper_bound()
            lower_bound(x)  返回大于等于x的最小的数的迭代器
            upper_bound(x)  返回大于x的最小的数的迭代器
~~~
###map/multimap
~~~C++
    map/multimap
        insert()  插入的数是一个pair
        erase()  输入的参数是pair或者迭代器
        find()
        []  注意multimap不支持此操作。 时间复杂度是 O(logn)
        lower_bound()/upper_bound()
~~~
###unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表
~~~C++
unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表
    和上面类似，增删改查的时间复杂度是 O(1)
    不支持 lower_bound()/upper_bound()， 迭代器的++，--
~~~
###bitset, 圧位
~~~C++
bitset, 圧位
    bitset<10000> s;
    ~, &, |, ^
    >>, <<
    ==, !=
    []

    count()  返回有多少个1

    any()  判断是否至少有一个1
    none()  判断是否全为0

    set()  把所有位置成1
    set(k, v)  将第k位变成v
    reset()  把所有位变成0
    flip()  等价于~
    flip(k) 把第k位取反

作者：yxc
链接：https://www.acwing.com/blog/content/404/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
~~~











# 搜索与图论

## dfs深度遍历

### n皇后

~~~C++
#include<iostream>
using namespace std;

int const N = 10;
bool col[N],dig[2*N],udig[2*N];
char path[N][N];

int n;

void dps(int u)
{
    if(u==n)
    {
        for(int i=0;i<n;i++)    puts(path[i]);
        puts("");
        return;
    }
    
    for(int i=0;i<n;i++)
    {
        if(!col[i]  && !dig[u+i] && !udig[u-i+n])
        {
            path[u][i]='Q';
            col[i]=dig[u+i]=udig[u-i+n]=true;
            dps(u+1);
            path[u][i]='.';
            col[i]=dig[u+i]=udig[u-i+n]=false;
        }
    }
}

int main()
{
    cin>>n;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n; j ++ )
            path[i][j] = '.';
    
    dps(0);
    return 0;
}
~~~

### 树的重心

![alt](D:\系统默认\图片\算法图\树的重心.png)

~~~C++
#include<iostream>
#include<algorithm>
#include<cstring>

using namespace std;

int const N =100010;
int h[N],e[2*N],ne[2*N];	//e[2*N]是因为所有的边的信息都储存在一个数组中
bool st[N];
int idx,n,ans=N;

void add(int a,int b)
{
    e[idx]=b;
    ne[idx]=h[a];
    h[a]=idx++;
}

int dfs(int u)
{
    int res=0;
    int sum=1;
    st[u]=true;
    for(int i=h[u];i!=-1 && !st[e[i]];i=ne[i])
    {
        int s=dfs(e[i]);        //注意dfs[e[i]];
        sum+=s;
        res=max(res,s);
    }
    res=max(res,n-sum);         
    //注意要放在循环的外面，因为只有等循环结束了，此时的sum才是加上真正的sum
    ans=min(ans,res);
    return sum;
}



int main()
{
    memset(h,-1,sizeof h);
    memset(st,false,sizeof st);
    
    
    
    cin>>n;
    for(int i=0;i<n-1;i++)
    {
        int a,b;
        cin>>a>>b;
        add(a,b);
        add(b,a);
    }


    dfs(1);
    cout<<ans;
    return 0;
    
}


~~~





## bfs广度遍历

### 图中点的层次

~~~C++
#include<iostream>
#include<queue>
#include<cstring>
using namespace std;


int const N =100010;
int h[N],e[N],ne[N],idx,st[N];

int d[N];

void add(int a,int b)
{
    e[idx]=b,ne[idx]=h[a],h[a]=idx++;
}

void bfs(int u)
{
    memset(d,-1,sizeof d);
    d[u]=0;
    queue<int>  q;
    q.push(u);
    st[u]=true;
    
    while(!q.empty())
    {
        int t=q.front();
        q.pop();
        for(int i=h[t];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(!st[j])
            {
                st[j]=true;
                d[j]=d[t]+1;			//注意是++不是+1
                q.push(j);
            }
        }
    }
    return;
}




int main()
{
    memset(h,-1,sizeof h);
    int n,m;
    cin>>n>>m;
    while(m--)
    {
        int a,b;
        cin>>a>>b;
        add(a,b);
    }
    memset(st,false,sizeof st);
    bfs(1);
    cout<<d[n];
    
    
    return 0;
    
}
~~~

###迷宫找出口

~~~C++
#include<iostream>
#include<cstring>
#include<queue>
using namespace std;

typedef pair<int,int> PII;
int const N =110;
int g[N][N],d[N][N];

int main()
{
    int n,m;
    cin>>n>>m;
    for(int i=0;i<n;i++)
    for(int j=0;j<m;j++)
    cin>>g[i][j];
    
    queue<PII> q;
    q.push({0,0});
    memset(d,-1,sizeof(d));
    d[0][0]=0;
    
    int dx[4]={-1,0,1,0};
    int dy[4]={0,1,0,-1};
    
    while(!q.empty())
    {
        PII t=q.front();
        q.pop();
        for(int i=0;i<4;i++)
        {
            int x=t.first+dx[i];
            int y=t.second+dy[i];
            if(x>=0 && x<n && y>=0 && y<m && !g[x][y] && d[x][y]==-1)
            {
                q.push({x,y});
                d[x][y]=d[t.first][t.second]+1;
            }
        }
    }
    cout<<d[n-1][m-1];
    return 0;
}
~~~



###有向图的拓扑序列

**重要的步骤是找到入度为0的点，将其放入队列中进行**

**易错code**

~~~C++
void add(int a,int b)
{
    e[idx]=b,ne[idx]=h[a],h[a]=idx++;
    d[b]++;			//注意是是入度加一所以是d[b]++；
}


while(hh<=tt)
    {
        int t=q[hh++];		//注意是h++，不是h--；
        for(int i=h[t];i!=-1;i=ne[i])
        {
            int j=e[i];
            d[j]--;			//注意每次遍历的时候都要将各点的入度减一
            if(!d[j])   q[++tt]=j;
        }
    }
~~~

**完整code**

~~~C++
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;

int const N = 100010;
int h[N],e[N],ne[N],idx;
int d[N];           //记录各点的入度；
int q[N],tt=-1,hh=0;
int n,m;

void add(int a,int b)
{
    e[idx]=b,ne[idx]=h[a],h[a]=idx++;
    d[b]++;			//注意是是入度加一所以是d[b]++；
}

bool topSort()
{
    for(int i=1;i<=n;i++)   //入度为0放入队列中
    {
        if(!d[i])   q[++tt]=i;
    }
    while(hh<=tt)
    {
        int t=q[hh++];		//注意是h++，不是h--；
        for(int i=h[t];i!=-1;i=ne[i])
        {
            int j=e[i];
            d[j]--;			//注意每次遍历的时候都要将各点的入度减一
            if(!d[j])   q[++tt]=j;
        }
    }
    
    return(tt==n-1);
}

int main()
{
    memset(h,-1,sizeof h);
    cin>>n>>m;
    while(m--)
    {
        int a,b;
        cin>>a>>b;
        add(a,b);
    }
    if(topSort())
    {
        for(int i=0;i<=tt;i++)   cout<<q[i]<<" ";
    }
    else cout<<-1;
    return 0;
}
~~~

## 最短路径

### 朴素dijkstra   适用于单源有权稠密图

**思路**：选取起点，再寻找下一个dist最小点，再将剩下点的dist更新

~~~C++
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;


int const N = 510;
int g[N][N],dist[N];
int m,n;
bool st[N];

int Dijksra(int a,int b)
{
    memset(dist,0x3f,sizeof dist);
    dist[a]=0;
    for(int i=0;i<n;i++)
    {
        int t=-1;
        for(int j=1;j<=n;j++)
        {
            
            if(!st[j] &&(t==-1 ||dist[j]<dist[t]))   t=j;
        }
            st[t]=true;
        for(int j=1;j<=n;j++)
        {
            //if(!st[j])可加可不加
            dist[j]=min(dist[j],dist[t]+g[t][j]);
        }
    }
    if(dist[b]==0x3f3f3f3f) return -1;
    else    return dist[b];
}



int main()
{
    memset(g,0x3f,sizeof g);
    memset(st,false,sizeof st);
    
    cin>>n>>m;
    while(m--)
    {
        int x,y,d;
        cin>>x>>y>>d;
        g[x][y]=min(g[x][y],d);
    }
    
    cout<<Dijksra(1,n);
    return 0;
    
}
~~~

### 堆排序优化 用于稀疏图

想找到起点，然后找未遍历后驱，然后按照点与后驱上的边的权值更新后驱dist，直到堆空

~~~C++
#include<iostream>
#include<cstring>
#include<iostream>
#include<queue>
using namespace std;
typedef pair<int,int> PII;

int const N = 1.5e5+10;
int h[N],e[N],ne[N],w[N],idx;
bool st[N];
int dist[N];
int m,n;

void add(int a,int b,int d)
{
    e[idx]=b,w[idx]=d,ne[idx]=h[a],h[a]=idx++;
}

int djikstra(int a,int b)
{
    memset(dist,0x3f,sizeof dist);
    dist[a]=0;
    priority_queue<PII,vector<PII>,greater<PII>>    heap;
    heap.push({0,a});
    while(!heap.empty())
    {
        PII t=heap.top();
        heap.pop();
        int var=t.second,distance=t.first;
        if(st[var]) continue;		//我相通了，此时堆
        st[var]=true;
        
        for(int i=h[var];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(dist[j]>distance+w[i])
            {
                dist[j]=distance+w[i];
                heap.push({dist[j],j});
            }
        }
    }
    if(dist[b]==0x3f3f3f3f) return -1;
    return dist[b];
}

int main()
{
    memset(h,-1,sizeof h);
    cin>>n>>m;
    while(m--)
    {
        int a,b,d;
        cin>>a>>b>>d;
        add(a,b,d);
    }
    
    cout<<djikstra(1,n);
    return 0;
}
~~~

### Bellman算法——计算带负权边以及限制边数的问题

~~~C++
int n, m;       // n表示点数，m表示边数
int dist[N];        // dist[x]存储1到x的最短路距离

struct Edge     // 边，a表示出点，b表示入点，w表示边的权重
{
    int a, b, w;
}edges[M];

// 求1到n的最短路距离，如果无法从1走到n，则返回-1。
int bellman_ford()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。
    for (int i = 0; i < n; i ++ )
    {
        for (int j = 0; j < m; j ++ )
        {
            int a = edges[j].a, b = edges[j].b, w = edges[j].w;
            if (dist[b] > dist[a] + w)
                dist[b] = dist[a] + w;
        }
    }

    if (dist[n] > 0x3f3f3f3f / 2) return -1;
    return dist[n];
}
~~~



### spfa算法——计算带负权边的最短路径

时间复杂度 平均情况下 O(m)O(m)，最坏情况下 O(nm)O(nm), n 表示点数，m 表示边数

~~~C++
int n;      // 总点数
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N];        // 存储每个点到1号点的最短距离
bool st[N];     // 存储每个点是否在队列中

// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1
int spfa()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    queue<int> q;
    q.push(1);
    st[1] = true;

    while (q.size())
    {
        auto t = q.front();
        q.pop();

        st[t] = false;

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                if (!st[j])     // 如果队列中已存在j，则不需要将j重复插入
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
~~~

### spfa算法

~~~C++
int n;      // 总点数
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N];        // 存储每个点到1号点的最短距离
bool st[N];     // 存储每个点是否在队列中

// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1
int spfa()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    queue<int> q;
    q.push(1);
    st[1] = true;

    while (q.size())
    {
        auto t = q.front();
        q.pop();

        st[t] = false;

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                if (!st[j])     // 如果队列中已存在j，则不需要将j重复插入
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
~~~

###floyd算法——多源汇最短路径 n^3

~~~C++
初始化：
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= n; j ++ )
            if (i == j) d[i][j] = 0;
            else d[i][j] = INF;

// 算法结束后，d[a][b]表示a到b的最短距离
void floyd()
{
    for (int k = 1; k <= n; k ++ )
        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= n; j ++ )
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}
~~~



##最小生成树

###朴素版prim n^2+m

~~~C++
int n;      // n表示点数
int g[N][N];        // 邻接矩阵，存储所有边
int dist[N];        // 存储其他点到当前最小生成树的距离
bool st[N];     // 存储每个点是否已经在生成树中


// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和
int prim()
{
    memset(dist, 0x3f, sizeof dist);

    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
        if (i && dist[t] == INF) return INF;
         if (i) res += dist[t];
        st[t] = true;

        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
    }
    
    return res;
}
~~~



### kruskal算法	mlogm

~~~C++
int n, m;       // n是点数，m是边数
int p[N];       // 并查集的父节点数组

struct Edge     // 存储边
{
    int a, b, w;

    bool operator< (const Edge &W)const
    {
        return w < W.w;
    }
}edges[M];

int find(int x)     // 并查集核心操作
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int kruskal()
{
    sort(edges, edges + m);

    for (int i = 1; i <= n; i ++ ) p[i] = i;    // 初始化并查集

    int res = 0, cnt = 0;
    for (int i = 0; i < m; i ++ )
    {
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;

        a = find(a), b = find(b);
        if (a != b)     // 如果两个连通块不连通，则将这两个连通块合并
        {
            p[a] = b;
            res += w;
            cnt ++ ;
        }
    }

    if (cnt < n - 1) return INF;
    return res;
}

~~~

## 二分图

### 染色法

~~~C++
int n;      // n表示点数
int h[N], e[M], ne[M], idx;     // 邻接表存储图
int color[N];       // 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色

// 参数：u表示当前节点，c表示当前点的颜色
bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (color[j] == -1)
        {
            if (!dfs(j, !c)) return false;
        }
        else if (color[j] == c) return false;
    }

    return true;
}

bool check()
{
    memset(color, -1, sizeof color);
    bool flag = true;
    for (int i = 1; i <= n; i ++ )
        if (color[i] == -1)
            if (!dfs(i, 0))
            {
                flag = false;
                break;
            }
    return flag;
}

~~~

### 匈牙利算法

~~~C++
int n1, n2;     // n1表示第一个集合中的点数，n2表示第二个集合中的点数
int h[N], e[M], ne[M], idx;     // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边
int match[N];       // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个
bool st[N];     // 表示第二个集合中的每个点是否已经被遍历过

bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }

    return false;
}
// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点
int res = 0;
for (int i = 1; i <= n1; i ++ )
{
    memset(st, false, sizeof st);
    if (find(i)) res ++ ;
}
~~~



# 数学知识

## 数论

### 判断质数

~~~C++
bool is_prime(int x)
{
    if (x < 2) return false;
    for (int i = 2; i <= x / i; i ++ )		//注意此处的i<=x/i的写法；
        if (x % i == 0)
            return false;
    return true;
}
~~~





###分解质因数

~~~C++
void divide(int x)
{
    for (int i = 2; i <= x / i; i ++ )	
        if (x % i == 0)		
            //注意此处的i一定为质数，若为合数则i能被前面的质数乘积得出，所以，不可能为合数
        {
            int s = 0;
            while (x % i == 0) x /= i, s ++ ;
            cout << i << ' ' << s << endl;
        }
    if (x > 1) cout << x << ' ' << 1 << endl;
    cout << endl;
}
~~~

 

### 筛选素数

#### 朴素筛法

~~~C++
void find_prime(int n)
{
    for(int i=2;i<=n;i++)
    {
        if(!st[i])  prime[cnt++]=i;
        for(int j=i;j<=n;j+=i)  st[j]=true;
    }
}
~~~

####诶氏筛法

~~~C++
void find_prime(int n)
{
    for(int i=2;i<=n;i++)
    {
        if(!st[i])  
        {
            prime[cnt++]=i;
            for(int j=i;j<=n;j+=i)  st[j]=true;
        }
    }
}
~~~

####线性筛法

~~~C++
void find_prime(int n)
{
    for(int i=2;i<=n;i++)
    {
        if(!st[i])  prime[cnt++]=i;
        for(int j=0;prime[j]<=n/i;j++)
        {
            st[i*prime[j]]=true;
            if(i%prime[j]==0)   break;
        }
    }
}
~~~

### 求约数

~~~C++
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
int n;

vector<int> get_divisior(int x)
{
    vector<int> answer;
    for(int i=1;i<=x/i;i++)
    {
        if(x%i==0)
        {
            answer.push_back(i);
            if(i!=x/i)  answer.push_back(x/i);      //注意此处的判断，如果i==x/i，那么只加入一个；
        }
    }
    sort(answer.begin(),answer.end());
    return answer;
}

int main()
{
    cin>>n;
    while(n--)
    {
        int x;
        cin>>x;
        auto answer=get_divisior(x);
        for(int t:answer)
        {
            printf("%d ",t);
        }
        printf("\n");
    }   
}
~~~

# 动态规划

## 背包问题

![背包问题](https://cdn.acwing.com/media/article/image/2019/09/13/1833_e192f0d8d6-Snipaste_2019-09-13_17-06-58.png)

### 01背包	

有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。

第 i 件物品的体积是 vi，价值是 wi。

~~~C++
#include<iostream>
using namespace std;

int const N = 1010;
int f[N],V,w[N],v[N];

int main()
{
    int n;
    cin>>n>>V;
    for(int i=1;i<=n;i++)
    cin>>v[i]>>w[i];
 
    //优化前	注意[j-v[i]]<j,所以先j++的话先更新，此时为f[i][j-v[i]],所以应该j--优化
     for(int i=1;i<=n;i++)
        for(int j=1;j<=V;j++)
        {
            f[i][j]=f[i-1][j];
            if(j>=v[i]) f[i][j]=max(f[i-1][j],f[i-1][j-v[i]]+w[i]);
        }
    
    //滚动数组优化后 
    for(int i=v[i];i<=n;i++)
        for(int j=V;j>=v[i];j--)
        {
            //f[i][j]=f[i-1][j];
            f[j]=max(f[j],f[j-v[i]]+w[i]);
        }
    cout<<f[V]<<endl;
    
    return 0;
}
~~~



### 完全背包	

有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。

第 i 种物品的体积是 vi，价值是 wi。

![image-20230321151510596](/home/papupupu/.config/Typora/typora-user-images/image-20230321151510596.png)

~~~C++
#include<iostream>
using namespace std;

int const N = 1010;
int f[N][N],v[N],w[N],V;

int main()
{
    int n;
    cin>>n>>V;
    for(int i=1;i<=n;i++)
    cin>>v[i]>>w[i];
    //未优化前
    for(int i=1;i<=n;i++)
        for(int j=1;j<=V;j++)
        {
            for(int k=0;k*v[i]<=j;k++)
            {
                f[i][j]=max( f[i][j],f[i-1][j-k*v[i]]+k*w[i] );
            }
        }
    //优化k后
    for(int i=1;i<=n;i++)
        for(int j=1;j<=V;j++)
        {
            f[i][j]=f[i-1][j];
            if(j>=v[i]) f[i][j]=max(f[i-1][j],f[i][j-v[i]]+w[i]);
        }
    //滚动数组优化后
    for(int i=1;i<=n;i++)
        for(int j=v[i];j<=V;j++)
        {
            //f[i][j]=f[i-1][j];
            f[j]=max(f[j],f[j-v[i]]+w[i]);
        }
    
    
    
    cout<<f[V];
    return 0;
}
~~~

### 多重背包 

有 N 种物品和一个容量是 V 的背包。

第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。
输出最大价值。

~~~C++
#include<iostream>
using namespace std;

int const N = 12010;
int v[N],w[N],f[2010],V;

int  main()
{
    int n;
    cin>>n>>V;
    int cnt = 0;
    for(int i=1;i<=n;i++)
    {
        int a,b,s;
        cin>>a>>b>>s;
        int k=1;
        
        while(k < s)
        {
            v[++cnt] = k * a;
            w[cnt] = k * b;
            s -= k;
            k *= 2;
        }
    
        if(s)
        {
            v[++cnt] = s * a;
            w[cnt] =  s * b;
        }
    }
    
    
    for(int i = 1;i <= cnt;i++)
        for(int j = V;j >= v[i]; j--)
            f[j]=max( f[j], f[j-v[i]] + w[i]);
    
    cout<<f[V];
    return 0;
}
~~~



### 分组背包问题

有 N 组物品和一个容量是 V 的背包。

每组物品有若干个，同一组内的物品最多只能选一个。
每件物品的体积是 vij，价值是 wij，其中 i 是组号，j 是组内编号。

求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。

~~~C++
#include<iostream>
using namespace std;

int const N = 110;
int v[N][N],w[N][N],s[N],f[N],V;

int main()
{
    int n;
    cin>>n>>V;
    for(int i=1;i<=n;i++)
    {
        cin>>s[i];
        for(int j=1;j<=s[i];j++)
        cin>>v[i][j]>>w[i][j];
    }
    
    for(int i=1;i<=n;i++)
        for(int j=V;j>=0;j--)
            for(int k=1;k<=s[i];k++)
                if(j>=v[i][k])    f[j]=max(f[j],f[j-v[i][k]] + w[i][k]);
    
    cout<<f[V];
    return 0; 
}
~~~

## 计数问题

计算a到b中的所有数中位数上出现1到9的次数

~~~C++
#include<iostream>
using namespace std;

int dt(int x)
{
    int res=0;
    while(x)    x/=10,res++;
    return res;
}
int pow10(int i)
{
    int res=1;
    while(i--)  res*=10;
    return res;
}

int cnt(int x,int i)
{
    int d=dt(x);
    int res=0;
    for(int j=1;j<=d;j++)
    {
        int dj,l,r;
        int p=pow10(j-1);
        l=x/p/10,r=x%p,dj=x/p%10;	//注意此处
 		//以下条件想清楚
        if(i)   res+=l*p;	//i不为0，左边可取0到l-1，右边取0到p-1
        if(!i && l) res+=(l-1)*p;	//i为0 左边取1到l-1，右边取0到p-1
        if(dj>i && (l || i))    res+=p;	//
        if(dj==i && (l || i))   res+=r+1;
    }
    return res;
}


int main()
{
    int a,b;
    cin>>a>>b;
    while( a || b )
    {
        if(a>b) swap(a,b);
        for(int i=0;i<10;i++)   printf("%d ",cnt(b,i)-cnt(a-1,i));   
        printf("\n");
        cin>>a>>b;

    }    
    
    return 0;
    
}
~~~



## 状态dp

###**蒙德里安的梦想**

求把 N×M 的棋盘分割成若干个 1×2 的长方形，有多少种方案。

例如当 N=2，M=4 时，共有 55 种方案。当 N=2，M=3时，共有 33 种方案。

如下图所示：

![2411_1.jpg](https://www.acwing.com/media/article/image/2019/01/26/19_4dd1644c20-2411_1.jpg)

**输入格式

输入包含多组测试用例。

每组测试用例占一行，包含两个整数 NN 和 MM。

当输入用例 N=0，M=0 时，表示输入终止，且该用例无需处理。

~~~C++
#include<iostream>
using namespace std;
#include<cstring>
#include<vector>

int const N = 12,M =1 << N;
long long f[N][M];
bool st[M];
vector<vector<int>> statu;


int main()
{
    int n,m;
    while(cin>>n>>m && (m || n))
    {
        //预处理竖着的一列中二进制表示的状态能否
        for(int i = 0;i<(1<<n);i++){
            int cnt=0;
            st[i]=true;
            for(int j=0;j<n;j++){
                if(i>>j & 1){
                    if(cnt & 1){
                        st[i]=false;
                        break;
                    }
                cnt=0;
                }   
                else cnt++; 
            }
            if(cnt & 1) st[i]=false;
        }

        memset(f,0,sizeof f);
        f[0][0]=1;
        for(int i=1;i<=m;i++){
            for(int j=0;j<(1<<n);j++){
                for(int k=0;k<(1<<n);k++){
                    if( !(k & j) && st[k | j])
                    f[i][j]+=f[i-1][k];
                }                    
            }
        }
        cout<<f[m][0]<<endl;
    }
    return 0;

}
~~~

###最短Hamilton路径
给定一张 n 个点的带权无向图，点从 0∼n−1 标号，求起点 0 到终点 n−1 的最短 Hamilton 路径。
Hamilton 路径的定义是从 0 到 n−1 不重不漏地经过每个点恰好一次。

**特别注意>>和<<的区别和其比加减的优先级低，所以，==最好全部打上括号==，然后==>>是数字右移变小，<<是数字左移变大，血的教训==**

~~~C++
#include<iostream>
using namespace std;
#include<cstring>

int const N = 20, M = 1 << N;
int f[M][N],w[N][N];


int main()
{
    int n;
    cin>>n;
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++)
            cin>>w[i][j];
    
    memset(f,0x3f,sizeof f);
    f[1][0]=0;
    
    for(int i=1;i < (1<<n); i++)
        for(int j=0;j<n;j++)
            if(i>>j & 1){
                for(int k=0;k<n;k++){
                    if(  (i - (1<<j)) & (1<<k) )
                    {
                        f[i][j]=min(f[i][j],f[i-(1<<j)][k]+w[k][j]);
                    }   
                }
            }
    
    cout<<f[ (1<<n)-1 ][n-1]<<endl;
    return 0;
}
~~~

## 树形DP

### 没有上司的舞会

Ural 大学有 N 名职员，编号为 1∼N。他们的关系就像一棵以校长为根的树，父节点就是子节点的直接上司。每个职员有一个快乐指数，用整数 Hi 给出，其中 1≤i≤N。现在要召开一场周年庆宴会，不过，没有职员愿意和直接上司一起参会。在满足这个条件的前提下，主办方希望邀请一部分职员参会，使得所有参会职员的快乐指数总和最大，求这个最大值。

~~~C++
/*
显然是求相互隔开的节点的和
第一：树形结构用邻接表存，然后每个点存在值而不是每个边存在值，所以用happy[N],而不是w[N];
第二：每个点存在多个儿子，多个儿子树的和才是根树的值，所以即使无论f[u][1/0]都要+=,是求儿子的和
*/


#include<iostream>
using namespace std;
#include<cstring>

int const N = 6010;
int happy[N];	
bool has_father[N];
int f[N][2],e[N],ne[N],h[N],idx,n;

void add(int a,int b)
{
    e[idx]=b,ne[idx]=h[a],h[a]=idx++;
}

void dfs(int u)
{
    f[u][1]=happy[u];
    for(int i=h[u];i!=-1;i=ne[i])
    {
        int j=e[i];
        dfs(j);
        f[u][0]+=max(f[j][1],f[j][0]);	//注意都要+=
        f[u][1]+=f[j][0];				//注意都要+=
    }
    return;
}

int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    cin>>happy[i];

    memset(h,-1,sizeof h);
    for(int i=1;i<=n-1;i++)
    {
        int a,b;
        cin>>a>>b;
        add(b,a);
        has_father[a]=true;  
    }

    int root=0;
    while(has_father[++root]);

    dfs(root);

    printf("%d",max(f[root][1],f[root][0]));
    return 0;
}
~~~

## 记忆化dp

给定一个 RR 行 CC 列的矩阵，表示一个矩形网格滑雪场。

矩阵中第 ii 行第 jj 列的点表示滑雪场的第 ii 行第 jj 列区域的高度。

一个人从滑雪场中的某个区域内出发，每次可以向上下左右任意一个方向滑动一个单位距离。

当然，一个人能够滑动到某相邻区域的前提是该区域的高度低于自己目前所在区域的高度。

~~~C++
#include<iostream>
using namespace std;
#include<cstring>

int const N = 310;
int f[N][N],h[N][N];
int n,m;
int dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};


int dfs(int x,int y)
{
    if(f[x][y]!=-1)    return  f[x][y];
    f[x][y]=1;
    for(int i=0;i<4;i++)
    {
        int xx=x+dx[i], yy=y+dy[i];
        if(h[x][y]>h[xx][yy])
        f[x][y]=max(f[x][y],dfs(xx,yy)+1);
    } 
    return f[x][y];
}

int main()
{
    for(int i=0;i<N;i++)
        for(int j=0;j<N;j++)
            h[i][j]=0x3f3f3f3f;

    cin>>m>>n;
    for(int i=1;i<=m;i++)
        for(int j=1;j<=n;j++)
            cin>>h[i][j];
    
    int res=0;
    memset(f,-1,sizeof f);
    for(int i=1;i<=m;i++)
        for(int j=1;j<=n;j++)
            res=max(res,dfs(i,j));

    cout<<res;
    return 0;
}

~~~

# 贪心算法

## 区间问题

### 区间选点

给定 N 个闭区间 [ai,bi]请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点。输出选择的点的最小数量。位于区间端点上的点也算作区间内。

**思路**：将**右端点**进行排序，并选择右端点为选点，新区间不在区间内的话，则将其右端点放入选点中，选点更新为新的；

~~~C++
#include<iostream>
using namespace std;
#include<vector>
#include<algorithm>

typedef pair<int,int>   PII;

vector<PII> nums;

int main()
{
    int n;
    cin>>n;
    while(n--)
    {
        int l,r;
        cin>>l>>r;
        nums.push_back({r,l});
    }
    
    sort(nums.begin(),nums.end());
    
    int cnt=0;
    int idx=-2e9;
    for(auto num:nums)
    {
        int l=num.second;
        if(l>idx)   cnt++,idx=num.first;
    }
    
    cout<<cnt<<endl;
    return 0;
}
~~~

### 最大不相交区间数量 

给定 N 个闭区间 [ai,bi]，请你在数轴上选择若干区间，使得选中的区间之间互不相交（包括端点）。输出可选取区间的最大数量。**选课问题，选择最多的课不冲突**

**思路**：选择**右端点**排序，如果新的区间的l>group_r,放入，并更新r；

~~~C++
#include<iostream>
using namespace std;
#include<algorithm>

typedef pair<int,int>   PII;
vector<PII> nums,res;


int main()
{
    int n;
    cin>>n;
    while(n--)
    {
        int l,r;
        cin>>l>>r;
        nums.push_back({r,l});
    }
    
    sort(nums.begin(),nums.end());
    
    int ed=-2e9,st=-2e9;
    int cnt;
    for(auto num : nums)
    {
        cnt++;
        int r=num.first,l=num.second;
        if(l>ed)
        {
            res.push_back({l,r});
            st=l,ed=r;
        }
    }
    
    cout<<res.size()<<endl;
    return 0;
}

~~~



### 区间分组

给定 N 个闭区间 [ai,bi]请你将这些区间分成若干组，使得每组内部的区间两两之间（包括端点）没有交集，并使得组数尽可能小。

**思路**：区间分组用**左端点**排序，然后看然后看后面的区间能否合并之前组中，如果可以(now_l>group_r)，则合并，否则新开一个组；

~~~C++
#include<iostream>
using namespace std;
#include<vector>
#include<algorithm>
#include<queue>

typedef pair<int,int>   PII;
vector<PII> nums;
priority_queue<int,vector<int>,greater<int>> res;//小根堆优化

int main()
{
    int n;
    cin>>n;
    while(n--)
    {
        int l,r;
        cin>>l>>r;
        nums.push_back({l,r});
    }
    
    sort(nums.begin(),nums.end());
    
    for(auto num:nums)
    {
        int l=num.first,r=num.second;
        if(res.empty())
        {
             res.push(r);
             continue;
        }
        int min_r=res.top();
        if(l>min_r) res.pop();
        res.push(r);
    }
    
    cout<<res.size()<<endl;
    return 0;
}
~~~

### 区间覆盖

给定 NN 个闭区间 [ai,bi]以及一个线段区间 [s,t]请你选择尽量少的区间，将指定线段区间完全覆盖。

输出最少区间数，如果无法完全覆盖则输出 −1。

**思路**：首先先将**左端点**排序，再找出最大的r，将这个区间选上

~~~C++
#include<iostream>
using namespace std;
#include<algorithm>
int const N = 1e5+10;

struct Range{
    int l,r;
    bool operator <(const Range &W) const {
        return l<W.l;
    }
    
}range[N];


int main()
{
    int st,ed;
    cin>>st>>ed;
    
    int n;
    cin>>n;
    
    for(int i=0;i<n;i++)
    {
        int l,r;
        cin>>l>>r;
        range[i].l=l,range[i].r=r;
    }
    sort(range,range+n);
    int res=0;
    bool flag=false;
    for(int i=0;i<n;i++)
    {
        int j=i;
        int r=-2e9;
        while(j<n && range[j].l<=st)	//选择最大的r
        {
            r=max(r,range[j].r);
            j++;
        }
        if(r<st)
        {
            res=-1;
            break;
        }
        res++;
        if(r>=ed)
        {
            flag=true;
            break;
        }
        st=r;
        i=j-1;
    }
    if(!flag)   res=-1;
    cout<<res<<endl;
    return 0;
}
~~~

